# 定时器（timer）

## 一、基础知识

### 1.1 非活动连接以及定时的概念

* **非活动连接**：指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。
* **定时事件**：指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。
* **定时器**：指利用结构体或其他形式，将多种定时事件进行封装起来（项目中只涉及一种定时事件，即**定期检测非活跃连接**，这里将该定时事件与连接资源封装为一个结构体定时器）
* **定时器容器**：指使用某种容器类数据结构，将上述多个定时器组合起来，**便于对定时事件统一管理**。具体的，项目中使用**升序链表**将所有定时器串联组织起来。

### 1.2 定时方法

* 概述

  > 服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。

* Linux定时方法

  > 三种方法没有一劳永逸的应用场景，也没有绝对的优劣。**项目中使用的是`SIGALRM`信号**

  * `socket`选项`SO_RECVTIMEO`和`SO_SNDTIMEO`
  * `SIGALRM`信号
  * I/O复用系统调用的超时参数

* <font color='grenn'>`SIGALRM`信号</font>

  * 定时实现方式：利用`alarm`函数周期性地触发`SIGALRM`信号，信号处理函数利用**管道**通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。
  * 基础`API`：描述`sigaction`结构体、`sigaction`函数、`sigfillset`函数、`SIGALRM`信号、`SIGTERM`信号、`alarm`函数、`socketpair`函数、`send`函数。

### 1.3 信号通知流程

* Linux下的信号采用的**异步处理机制**：<u>信号处理函数和当前进程是两条不同的执行路线</u>。具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。

* 为避免信号竞态现象发生，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽可能快地执行完毕。

* 一般的信号处理函数需要处理该信号对应的逻辑，当该逻辑比较复杂时，信号处理函数执行时间过长，会导致信号屏蔽太久。

* 这里的解决方案是：**信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。**

* **统一事件源**：将信号事件和其它事件一样被处理。

  > * 信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值
  > * 主循环则从管道的读端读出信号值，使用**I/O复用系统调用来监听**管道读端的可读事件，这样**信号事件与其他文件描述符都可以通过epoll来监测**，从而实现统一处理。

* 信号通知逻辑

  > * 创建管道，其中管道写端写入信号值，管道读端通过I/O复用系统监测读事件
  >
  > * 设置信号处理函数`SIGALRM`（时间到了触发）和`SIGTERM`（kill会触发，`Ctrl+C`）
  >
  > * - 通过`struct sigaction`结构体和`sigaction`函数注册信号捕捉函数
  >   - 在结构体的`handler`参数设置信号处理函数，具体的，从管道写端写入信号的名字
  >
  > * 利用I/O复用系统监听管道读端文件描述符的可读事件
  >
  > * 信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码

### 1.4 信号处理机制

* 每个进程之中，都有存着一个表，里面存着每种信号所代表的含义，内核通过设置表项中每一个位来标识对应的信号类型。

![图片](定时器（timer）.assets/640.webp)

* 信号的接收

  * 接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。**注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。**

* 信号的检测

  * 进程陷入内核态后，有两种场景会对信号进行检测：
    * 进程从内核态返回到用户态前进行信号检测
    * 进程在内核态中，从睡眠状态被唤醒的时候进行信号检测

  * 当发现有新信号时，便会进入下一步，信号的处理。

* 信号处理

  * ( **内核** )信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。
  * ( **用户** )接下来进程返回到用户态中，执行相应的信号处理函数。
  * ( **内核** )信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。
  * ( **用户** )如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。

至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行（即用户检测到还有信号没处理，进入用户态执行信号处理函数，执行完毕返回内核态，检测是否还有信号未处理）。

## 二、模块设计
