# 半同步半反应堆线程池（threadpoll）

## 一、基础知识

### 1.1 服务器编程框架

1. **I/O处理单元**。处理客户连接，读写网络数据（服务器机群——作为接入服务器，实现负载均衡）

   等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端（数据收发可能不在I/O处理单元执行，也可能在逻辑单元，具体取决于采用的事件处理模式）—— 有哪些事件处理模式？Reactor/Proactor

2. **逻辑单元**。业务进程或线程（并发，多进程/线程）（服务器机群——逻辑服务器）
   	分析、处理客户数据，将结果传递给I/O处理单元或直接发给客户端

3. **存储单元**。本地数据库、文件或缓存（服务器机群——数据库服务器）

4. **请求队列**。各单元之间的通信方式的抽象。（服务器机群——各服务器间的永久TCP连接,提高数据交换效率）

   I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件（调度？）。请求队列通常被实现为池的一部分

### 1.2 五种I/O模型

1. **阻塞IO**：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作

2. **非阻塞IO**：非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成EAGAIN

3. **信号驱动IO**：linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。

4. **IO复用**：linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数

5. **异步IO**：linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

   > **阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。**
   >
   > * **同步I/O**：指内核向应用程序（工作线程/逻辑单元）通知**I/O就绪事件**，比如只通知有客户端连接，要求用户代码自行执行I/O操作
   > * **异步I/O**：是指内核向应用程序通知的是**I/O完成事件**，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。

### 1.3 事件处理模式

* Reactor模式

  * 主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。读写数据、接受新连接、处理客户请求都在工作线程完成。

  * 通常基于**同步I/O模型**实现

  * 基于同步I/O模型（以epoll_wait为例）的Reactor模式工作流程

    	<1>主线程往epoll内核事件表注册socket上的“读就绪事件”（指的是读客户请求）
    	<2>主线程调用epoll_wait等待socket上有数据可读
    	<3>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。
    	<4>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求（如读、写数据），然后往epoll内核事件表中注册该socket上的“写就绪事件”（指的是写客户请求处理结果）
    	<5>主线程调用epoll_wait等待socket可写
    	<6>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。
    	<7>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

* Proactor模式

  * 将所有I/O操作（读写数据、接受新连接）都交给主线程和内核处理，工作线程仅负责业务逻辑。
  * 通常基于**异步I/O**实现。也可以通过同步I/O模拟（本项目采用），因为异步I/O并不成熟，实际使用较少，并且Proactor更符合服务器编程框架。

* <font color ='grenn'>同步I/O模拟的Proactor模式</font>

  * 原理：“主线程执行数据读写操作”，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理（即Proactor的工作模式）

  * 工作流程

    	<1>主线程往epoll内核事件表中注册socket上的读就绪事件
    	<2>主线程调用epoll_wait等待socket上有数据可读
    	<3>当socket上有数据可读时，epoll_wait通知“主线程”（注意如果是基于异步I/O模型的Proactor，此处是通知工作线程）。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列
    	<4>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件
    	<5>主线程调用epoll_wait等待socket可写
    	<6>当socket可写时，epoll_wait通知“主线程”。主线程往socket上写入服务器处理客户请求的结果

### 1.4 并发模式

* 定义：I/O处理单元和多个逻辑单元之间协调完成任务的方法

* 编程实现方法：多进程、多线程

* 并发模式中的同步和异步

  * 同步：指的是程序完全按照代码序列的顺序执行。效率低、实时性差、实现逻辑简单
  * 异步：指的是程序的执行需要由系统事件来驱动（比如中断、信号等）。效率高、实时性好、实现逻辑复杂

* 两种并发编程模式

  * 领导者/追随者（Leader/Followers）模式

  * <font color ='grenn'>半同步/半异步（half-sync/half-async）</font>

    * 定义：同时使用同步线程和异步线程实现，因为服务器要求较好的实时性，且要求能够同时处理多个客户请求的应用程序。

    * 工作流程（基于Reactor事件处理模式）

      ```
      <1>同步线程——处理客户业务请求（逻辑单元）
      <2>异步线程——处理I/O事件（I/O处理单元，主线程）
      <3>异步线程（主线程）监听所有socket上的事件，若监听到客户请求，则将其封装成请求对象并插入请求队列中
      <4>请求队列通知某个同步线程（工作线程）来读取并处理对象
      ```

* 半同步/半异步的变体 —— <font color ='grenn'>半同步/半反应堆（half-sync/half-reactive）</font>（项目中使用）

  * 工作流程（基于**Proactor**事件处理模式）

    ```
    <1>主线程充当异步线程，负责监听所有socket上的事件
    <2>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
    <3>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
    <4>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权
    ```

    * 不同之处：主线程完成I/O监听和读写操作，工作线程只负责业务逻辑处理

### 1.5 池

* 原理：池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配（从池中获取资源比动态分配速度快读多）。处理完一个客户请求，将该资源放回池中，无需释放资源，从而避免了对内核的频繁访问，提高了效率。
* 本质：以空间换时间：通过服务器的硬件资源，换取运行效率。
* 类型
  * 内存池。用于socket的接收缓存和发送缓存
  * 进程池、线程池。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork或pthread_create等函数来创建进程和线程
  * 连接池。用于服务器或服务器机群的内部永久连接

## 二、模块设计

* 模块功能

  > 封装线程池，可以实现基于同步I/O模拟的Proactor以及基于同步I/O的Reactor事件处理模式。

* 模块组成

  ```C++
  #include<list>
  #include<cstdio>
  #include<exception>
  #include<pthread.h>
  #include"../lock/locker.h"
  #include "../CGImysql/sql_connection_pool.h"
  
  /*问题
  1.为什么线程池不是单例模式？理论上来说不应该是和日志系统一样，一个webserver对应一个线程池？
      回答：……
  
  2.为什么线程处理函数worker是静态函数？
      因为pthread_create要求输入的函数指针的参数是void*，若类成员worker不是静态成员，则会隐含传入this指针，和void*不匹配，导致错误
  
  3.为什么必须要用worker内部调用run，而不是直接将run作为线程调用函数？
  
  
  4.为什么要在同一个头文件中完成类的声明和实现？
      模板类通常需要在编译时对每个使用的类型实例化，这意味着模板定义需要对编译器可见。因此，模板的实现通常放在头文件中，而不是像非模板类那样分离头文件和源文件。主要是为了简化构建过程并避免与编译器相关的问题。
  */
  
  template<typename T>
  class threadpool{
  public:
      /*
      * actor_model：事件处理模式
      * connPool：数据库连接池对象
      * thread_number：线程池中线程的数量
      * max_requests：请求队列中最多允许的、等待处理的请求的数量
      * */
      threadpool(int actor_model, connection_pool *connPool, int thread_num = 8, int max_request = 10000);
      ~threadpool();
      /*
      * 功能：向请求队列中添加任务对象
      * request：任务对象（本项目中是http，但设计为模板类，所以也可以扩展为其它如ftp等
      * state：任务状态，本项目中为http请求的模式，0-读，1-写
      */
      bool append(T *request, int state);
      bool append_p(T *request);
  
  private:
      //工作线程运行函数，内部访问私有函数run，完成线程处理要求
      static void *worker(void *arg);
      //执行业务逻辑处理
      void run();
  
  private:
      int m_thread_number;        //线程池中的线程数
      int m_max_requests;         //请求队列允许的最大请求数（最大并发数量）
      pthread_t *m_threads;       //线程池数组，大小为m_thread_number
      std::list<T *> m_workqueue; //请求队列
      locker m_queuelocker;       //保护请求队列的互斥锁
      sem m_queuestat;            //信号量，通知工作线程是否有任务需要处理
      connection_pool *m_connPool;//数据库连接池
      int m_actor_model;          //反应堆模式切换，0-Proactor，1-Reactor
  };
  ```

  
