# 日志系统（log）

> * 说明：文档来源：[最新版Web服务器项目详解 - 09 日志系统（上） (qq.com)](https://mp.weixin.qq.com/s/IWAlPzVDkR2ZRI5iirEfCg)

## 一、基础知识

* **日志**：由服务器自动创建，并记录运行状态、错误信息、访问数据的文件。

* **同步日志**：日志写入函数与工作线程串行执行，由于涉及到I/O操作，**当单条日志比较大的时候，同步模式会阻塞整个处理流程**，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。

  * 解决方案：生产者-消费者模型

* **生产者-消费者模型**（异步日志系统的实现）

  * 生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。

  ![image-20240522171541766](日志系统.assets/image-20240522171541766.png)

  * 实现方式	
    * **阻塞队列**：将生产者-消费者模型进行封装，使用循环数组实现队列（或直接用STL的queue容器，但也需要封装），作为两者共享的缓冲区。
    * **异步日志**：将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。

## 二、模块设计

* 模块功能

  * 使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用**同步**和**异步**写入两种方式。
    * 同步写入：日志写入函数与工作线程串行执行。
    * 异步写入：将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

* 模块组成

  * 阻塞队列（block_queue）

    ```c++
    #include <iostream>
    #include <stdlib.h>
    #include <pthread.h>
    #include <sys/time.h>
    #include "../lock/locker.h"
    using namespace std;
    
    template<class T>
    class block_queue{
    public:
        //构造函数，队列大小默认为1000
        block_queue(int max_size = 1000);
        //清空队列
        void clear();
        //析构函数
        ~block_queue();
        //判断队列是否已满
        bool full();
        //判断队列是否为空
        bool empty();
        //返回队首元素（将队首元素赋值给value）
        bool front(T &value);
        //返回队尾元素
        bool back(T &value);
        //返回队列大小
        int size();
        //返回队列最大大小
        int max_size();
        //往队列添加元素(item是待写入日志)
        //1.添加元素后，需要唤醒所有使用队列的线程（广播）；若当前没有线程等待条件变量,则唤醒无意义
        //2.当有元素push进队列,相当于生产者生产了一个元素
        //3.若当前队列为满，则往队列添加元素的线程会被挂起（阻塞）
        bool push(const T &item);
        //从队列弹出元素
        //若当前队列为空，则从队列获取元素的线程会挂起（等待条件变量，阻塞）
        bool pop(T &item);
        //从队列弹出元素，并设置超时处理
        //1.不再使用while持续等待竞争资源，而是使用超时时间
        //2.若超时时间内获取timewait()成功返回，但m_size仍不大于0，说明资源已被其它线程使用，则立即返回并阻塞
        bool pop(T &item, int ms_timeout);
    private:
        locker m_mutex;	//互斥锁
        cond m_cond;	//条件变量，用于唤醒工作线程
        T *m_array;		//基于循环数组的队列，每个元素即为待写日志内容
        int m_size;     //队列元素数量
        int m_max_size; //队列最大容量
        int m_front;    //队头指针，指向队头的前一个元素，(m_front + 1) % m_max_size才指向真正的队头元素，m_front本身指向元素是已经取出的元素
        int m_back;     //队尾指针，指向队尾
    };
    ```

    * 问题

      * 为什么操作队列（添加元素/删除元素）前都需要加锁？

        > 多线程访问，为了避免资源竞争，所以要加锁，使得每个线程互斥的访问公有资源。

  * 日志类（log）

    * 单例模式：因为一个WebServer只需要一个日志系统，因此需要限制只能生成一个实例。
  
    ```C++
    #include <stdio.h>
    #include <iostream>
    #include <string>
    #include <stdarg.h>
    #include <pthread.h>
    #include "block_queue.h"
    using namespace std;
    class Log
    {
    public:
        //唯一的公共静态方法作为实例获取入口
        //线程安全问题：C++11以后,使用局部变量懒汉不用加锁（因为静态局部变量只初始化一次，后续会直接跳过）
        static Log *get_instance();
        //？？写日志，感觉也是调试用的？？
        static void *flush_log_thread(void *args);
        //日志系统初始化。可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列
        bool init(const char *file_name, int close_log, int log_buf_size = 8192, int split_lines = 5000000, int max_queue_size = 0);
        //写日志
        void write_log(int level, const char *format, ...);
        //？？？感觉像是调试用的，用于在关闭日志系统的时候，强制将调试信息写入日志文件？？
        void flush(void);
    private:
        //私有构造和析构，实现单例模式
        Log();
        virtual ~Log();
        //从阻塞队列中取出一个日志string，写入文件
        void *async_write_log();
    private:
        //饿汉模式（无需加锁即可实现线程安全）
        //static Log *instance;
        char dir_name[128]; //路径名
        char log_name[128]; //log文件名
        int m_split_lines;  //日志最大行数
        int m_log_buf_size; //日志缓冲区大小
        long long m_count;  //日志行数记录
        int m_today;        //因为按天分类,记录当前时间是那一天
        FILE *m_fp;         //打开log的文件指针
        char *m_buf;
        block_queue<string> *m_log_queue; //阻塞队列
        bool m_is_async;                  //是否同步标志位
        locker m_mutex;
        int m_close_log; //0-打开/1-关闭日志
    };
    
    #define LOG_DEBUG(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(0, format, ##__VA_ARGS__); Log::get_instance()->flush();}
    #define LOG_INFO(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(1, format, ##__VA_ARGS__); Log::get_instance()->flush();}
    #define LOG_WARN(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(2, format, ##__VA_ARGS__); Log::get_instance()->flush();}
    #define LOG_ERROR(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(3, format, ##__VA_ARGS__); Log::get_instance()->flush();}
    ```
  
  * C++11之前的单例模式设计——双检测锁模式
  
    * 为什么要用双检测？
  
      > **如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能**。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。
      >
      > * 为什么单检测要在检测前加锁？
      >
      >   因为如果在检测后加锁，p的状态随时可能发生变化。而双检测模式下，检测后加锁，然后又进行了检测，保证了线程安全。
  
    ```C++
    class single{
    private:
        //私有静态指针变量指向唯一实例
        static single *p;
        //静态锁，是由于静态函数只能访问静态成员
        static pthread_mutex_t lock;
        //私有化构造函数
        single(){
        	pthread_mutex_init(&lock, NULL);
        }
        ~single(){}
    public:
        //公有静态方法获取实例
        static single* getinstance();
    };
    pthread_mutex_t single::lock;
    single* single::p = NULL;
    single* single::getinstance(){
        if (NULL == p){
            pthread_mutex_lock(&lock);
            if (NULL == p){
                p = new single;
            }
            pthread_mutex_unlock(&lock);
        }
        return p;
    }
    ```
  
    